<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Course - Tracker</title>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<style>
  /* Style moderne minimaliste */
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    display: flex; flex-direction: column;
  }

  .point-bleu {
    width: 12px;
    height: 12px;
    background-color: #007aff;
    border: 2px solid white;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(0,122,255,0.7);
  }
  #map {
    flex: 1;
    min-height: 300px;
  }
  header {
    padding: 1rem;
    background: #1e1e1e;
    text-align: center;
    font-weight: 700;
    font-size: 1.4rem;
    color: #38a1db;
  }
  .stats {
    display: flex;
    justify-content: space-around;
    background: #222;
    padding: 1rem 0;
    font-size: 1.1rem;
  }
  .btn-container {
    text-align: center;
    margin: 1rem 0;
  }
  button {
    margin: 0 0.5rem;
    padding: 0.7rem 1.5rem;
    font-size: 1.2rem;
    background: #38a1db;
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover {
    background: #2691d9;
  }
  #startStopBtn {
    background: #28a745;
  }
  #startStopBtn.running {
    background: #dc3545;
  }

   #styleSelector {
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 1rem;
    }
    /* Bouton GPS */
    #locateBtn {
      position: absolute;
      top: 80px;
      right: 10px;
      z-index: 100;
      background: #38a1db;
      color: white;
      border: none;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
    }

  /* Style modal Historique */
  #historyModal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0; top: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    overflow-y: auto;
    padding: 2rem;
  }
  #historyModal.active {
    display: block;
  }
  #historyContent {
    max-width: 900px;
    margin: 0 auto;
    background: #1e1e1e;
    border-radius: 10px;
    padding: 1rem;
    color: #eee;
  }
  #historyContent h2 {
    text-align: center;
    margin-bottom: 1rem;
    color: #38a1db;
  }
  .run-item {
    background: #282828;
    border-radius: 8px;
    margin-bottom: 1rem;
    padding: 0.8rem;
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    align-items: center;
  }
  .run-info {
    flex: 1 1 200px;
    min-width: 200px;
  }
  .run-info div {
    margin-bottom: 0.3rem;
  }
  .mini-map {
    width: 250px;
    height: 150px;
    border-radius: 6px;
    flex: 0 0 250px;
    background: #000;
  }
  #closeHistoryBtn {
    display: block;
    margin: 0 auto 1rem auto;
    background: #dc3545;
  }
</style>
</head>
<body>
<header>Course-app</header>

<button id="locateBtn" title="Me localiser">üìç</button>

<!-- Menu pour changer le fond de carte -->
<div style="text-align:center; margin: 0.5rem;">
  <select id="styleSelector">
    <option value="mapbox://styles/mapbox/outdoors-v12">Outdoors</option>
    <option value="mapbox://styles/mapbox/satellite-streets-v12">Satellite</option>
    <option value="mapbox://styles/mapbox/streets-v12">Streets</option>
    <option value="mapbox://styles/mapbox/dark-v11">Dark</option>
  </select>
</div>
<div id="map"></div>
<div class="stats">
  <div>Distance : <br><span id="distance">0</span> km</div>
  <div>D√©nivel√© : <br><span id="elevation">0</span> m</div>
  <div>Km-effort : <br><span id="kmEffort">0</span></div>
  <div>Temps : <br><span id="time">00:00:00</span></div>
</div>
<div class="btn-container">
  <button id="startStopBtn">D√©marrer la course</button>
  <button id="historyBtn">Historique</button>
</div>
<div id="wakeLockMessage" style="
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 15px 25px;
  border-radius: 10px;
  font-size: 16px;
  text-align: center;
  z-index: 1000;
  max-width: 90%;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
">
  ‚ÑπÔ∏è Veuillez ne pas verrouiller votre t√©l√©phone et garder cette application ouverte pour continuer le suivi en temps r√©el.
</div>


<!-- Modal Historique -->
<div id="historyModal">
  <div id="historyContent">
    <h2>Historique des courses</h2>
    <button id="closeHistoryBtn">Fermer</button>
    <div id="runsList">
      <!-- Courses enregistr√©es ici -->
    </div>
  </div>
</div>

<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<script>
  mapboxgl.accessToken = 'pk.eyJ1IjoiZ3ViaW5xIiwiYSI6ImNrbnlubnVwYjBsMjgyb3J4b3hqM2YwOGsifQ.KV-VZe4nIEMc7rhtHmM5BQ';

  let map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/outdoors-v12',
    center: [2.3522, 48.8566],
    zoom: 13
  });

   // Cr√©ation de l'√©l√©ment point bleu
  const el = document.createElement('div');
  el.className = 'point-bleu';

  // Cr√©ation du marker avec cet √©l√©ment
  const markerPointBleu = new mapboxgl.Marker(el)
    .setLngLat([2.3522, 48.8566]) // Position initiale
    .addTo(map);

  // Fonction pour mettre √† jour la position du marker
  function updatePosition(lat, lon) {
    markerPointBleu.setLngLat([lon, lat]);
    // Optionnel : recentrer la carte sur la position
    map.setCenter([lon, lat]);
  }

  // Suivi de la position avec g√©olocalisation
  if ('geolocation' in navigator) {
    navigator.geolocation.watchPosition((position) => {
      const lat = position.coords.latitude;
      const lon = position.coords.longitude;
      updatePosition(lat, lon);
    }, (error) => {
      console.error('Erreur g√©olocalisation :', error);
    }, {
      enableHighAccuracy: true,
      maximumAge: 10000,
      timeout: 5000
    });
  } else {
    alert('G√©olocalisation non support√©e par ce navigateur.');
  }

  // Fonction pour centrer la carte sur l'utilisateur
document.getElementById('locateBtn').addEventListener('click', () => {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        map.flyTo({ center: [longitude, latitude], zoom: 15 });
        new mapboxgl.Marker({ color: '#38a1db' })
          .setLngLat([longitude, latitude])
          .addTo(map);
      },
      (error) => {
        alert("Impossible d'obtenir la position actuelle.");
        console.error(error);
      },
      { enableHighAccuracy: true }
    );
  } else {
    alert("G√©olocalisation non support√©e.");
  }
});

// Changer le fond de carte
document.getElementById('styleSelector').addEventListener('change', (e) => {
  map.setStyle(e.target.value);
});


  let isRunning = false;
  let watchId;
  let positions = [];
  let startTime, elapsedTimeInterval;
  let elevationTotal = 0;

  const distanceEl = document.getElementById('distance');
  const elevationEl = document.getElementById('elevation');
  const kmEffortEl = document.getElementById('kmEffort');
  const timeEl = document.getElementById('time');
  const startStopBtn = document.getElementById('startStopBtn');

  const historyBtn = document.getElementById('historyBtn');
  const historyModal = document.getElementById('historyModal');
  const runsList = document.getElementById('runsList');
  const closeHistoryBtn = document.getElementById('closeHistoryBtn');

  function formatTime(ms) {
    let totalSeconds = Math.floor(ms / 1000);
    let h = String(Math.floor(totalSeconds / 3600)).padStart(2,'0');
    let m = String(Math.floor((totalSeconds % 3600)/60)).padStart(2,'0');
    let s = String(totalSeconds % 60).padStart(2,'0');
    return `${h}:${m}:${s}`;
  }

  function calculateDistance(coord1, coord2) {
    const R = 6371e3;
    const lat1 = coord1.latitude * Math.PI/180;
    const lat2 = coord2.latitude * Math.PI/180;
    const dLat = (coord2.latitude - coord1.latitude) * Math.PI/180;
    const dLon = (coord2.longitude - coord1.longitude) * Math.PI/180;

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1)*Math.cos(lat2)*
              Math.sin(dLon/2)*Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }

  function updateStats() {
    if (positions.length < 2) return;

    let totalDist = 0;
    for(let i=1; i<positions.length; i++) {
      totalDist += calculateDistance(positions[i-1], positions[i]);
    }
    let distKm = (totalDist / 1000).toFixed(2);
    distanceEl.textContent = distKm;

    elevationTotal = 0;
    for(let i=1; i<positions.length; i++) {
      let diff = positions[i].altitude - positions[i-1].altitude;
      if(diff > 0) elevationTotal += diff;
    }
    elevationEl.textContent = Math.round(elevationTotal);

    let kmEffort = distKm * (1 + elevationTotal / 100);
    kmEffortEl.textContent = kmEffort.toFixed(2);
  }

  function drawPath() {
    if (map.getSource('route')) {
      map.getSource('route').setData({
        "type": "Feature",
        "geometry": {
          "type": "LineString",
          "coordinates": positions.map(p => [p.longitude, p.latitude])
        }
      });
    } else {
      map.addSource('route', {
        "type": "geojson",
        "data": {
          "type": "Feature",
          "geometry": {
            "type": "LineString",
            "coordinates": positions.map(p => [p.longitude, p.latitude])
          }
        }
      });
      map.addLayer({
        "id": "route",
        "type": "line",
        "source": "route",
        "layout": {
          "line-join": "round",
          "line-cap": "round"
        },
        "paint": {
          "line-color": "#38a1db",
          "line-width": 5
        }
      });
    }
  }

  function updateTime() {
    const now = Date.now();
    const elapsed = now - startTime;
    timeEl.textContent = formatTime(elapsed);
  }

  function saveRun() {
    let runs = JSON.parse(localStorage.getItem('runs') || '[]');
    const runData = {
      id: Date.now(),
      date: new Date().toISOString(),
      positions,
      distance: parseFloat(distanceEl.textContent),
      elevation: elevationTotal,
      kmEffort: parseFloat(kmEffortEl.textContent),
      durationMs: Date.now() - startTime
    };
    runs.push(runData);
    localStorage.setItem('runs', JSON.stringify(runs));
  }

  function startRun() {
    if (!navigator.geolocation) {
      alert('G√©olocalisation non support√©e par votre navigateur.');
      return;
    }
    isRunning = true;
    startStopBtn.textContent = 'Arr√™ter la course';
    startStopBtn.classList.add('running');
    positions = [];
    elevationTotal = 0;
    distanceEl.textContent = '0';
    elevationEl.textContent = '0';
    kmEffortEl.textContent = '0';
    timeEl.textContent = '00:00:00';

    startTime = Date.now();
    elapsedTimeInterval = setInterval(updateTime, 1000);

    let lastCoords = null;

watchId = navigator.geolocation.watchPosition(
  (pos) => {
    const coords = {
      latitude: pos.coords.latitude,
      longitude: pos.coords.longitude,
      altitude: pos.coords.altitude || 0,
      timestamp: pos.timestamp
    };

    if (lastCoords) {
      const distance = getDistanceFromLatLonInMeters(lastCoords, coords);
      const timeDiff = coords.timestamp - lastCoords.timestamp;

      // Ignorer si distance > 50m en moins de 2 secondes (point aberrant)
      if (distance > 50 && timeDiff < 2000) {
        console.log('Point GPS ignor√© : aberration d√©tect√©e');
        return;
      }

      // Ignorer si points trop proches en temps (< 500ms)
      if (timeDiff < 500) {
        return;
      }
    }

    positions.push(coords);
    lastCoords = coords;

    map.flyTo({center: [coords.longitude, coords.latitude], zoom: 15});

    updateStats();
    drawPath();
  },
  (err) => {
    console.error('Erreur g√©oloc :', err);
  },
  { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 }
);

// Fonction pour calculer la distance entre 2 coordonn√©es en m√®tres
function getDistanceFromLatLonInMeters(coord1, coord2) {
  const R = 6371000; // Rayon Terre en m√®tres
  const dLat = deg2rad(coord2.latitude - coord1.latitude);
  const dLon = deg2rad(coord2.longitude - coord1.longitude);
  const a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(coord1.latitude)) * Math.cos(deg2rad(coord2.latitude)) *
    Math.sin(dLon/2) * Math.sin(dLon/2)
  ;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function deg2rad(deg) {
  return deg * (Math.PI/180);
}

  }

  function stopRun() {
    isRunning = false;
    startStopBtn.textContent = 'D√©marrer la course';
    startStopBtn.classList.remove('running');
    clearInterval(elapsedTimeInterval);
    if(watchId) navigator.geolocation.clearWatch(watchId);
    if(positions.length > 1) {
      saveRun();
      // Ici on pourrait afficher un r√©sum√© ou rediriger vers fin.html
      alert('Course enregistr√©e dans l\'historique.');
    } else {
      alert('Parcours trop court, aucun enregistrement effectu√©.');
    }
  }

  startStopBtn.addEventListener('click', () => {
    if (isRunning) {
      stopRun();
    } else {
      startRun();
    }
  });

  // Historique - gestion modal
  historyBtn.addEventListener('click', () => {
    showHistory();
  });
  closeHistoryBtn.addEventListener('click', () => {
    historyModal.classList.remove('active');
    // Nettoyer maps miniatures
    runsList.innerHTML = '';
  });

  // Afficher l'historique
  function showHistory() {
  runsList.innerHTML = '';
  let runs = JSON.parse(localStorage.getItem('runs') || '[]');

  if (runs.length === 0) {
    runsList.innerHTML = '<p>Aucune course enregistr√©e.</p>';
    return;
  }

  // Trier par date d√©croissante
  runs.sort((a, b) => b.id - a.id);

  runs.forEach(run => {
    const runDiv = document.createElement('div');
    runDiv.classList.add('run-item');

    // Infos textuelles
    const infoDiv = document.createElement('div');
    infoDiv.classList.add('run-info');
    infoDiv.innerHTML = `
      <div><strong>Date :</strong> ${new Date(run.date).toLocaleString()}</div>
      <div><strong>Distance :</strong> ${run.distance.toFixed(2)} km</div>
      <div><strong>D√©nivel√© :</strong> ${Math.round(run.elevation)} m</div>
      <div><strong>Km-effort :</strong> ${run.kmEffort.toFixed(2)}</div>
      <div><strong>Dur√©e :</strong> ${formatTime(run.durationMs)}</div>
    `;

    // Mini carte Mapbox
    const miniMapDiv = document.createElement('div');
    miniMapDiv.classList.add('mini-map');

    runDiv.appendChild(infoDiv);
    runDiv.appendChild(miniMapDiv);

    // Bouton Partager
    const shareButton = document.createElement('button');
    shareButton.textContent = 'Partager';
    shareButton.classList.add('share-btn');
    runDiv.appendChild(shareButton);

    runsList.appendChild(runDiv);

    // Initialiser mini map avec parcours
    const miniMap = new mapboxgl.Map({
      container: miniMapDiv,
      style: 'mapbox://styles/mapbox/outdoors-v12',
      interactive: false,
      center: [run.positions[0].longitude, run.positions[0].latitude],
      zoom: 13,
      attributionControl: false
    });

    miniMap.on('load', () => {
      miniMap.addSource('route', {
        "type": "geojson",
        "data": {
          "type": "Feature",
          "geometry": {
            "type": "LineString",
            "coordinates": run.positions.map(p => [p.longitude, p.latitude])
          }
        }
      });

      miniMap.addLayer({
        "id": "route",
        "type": "line",
        "source": "route",
        "layout": {
          "line-join": "round",
          "line-cap": "round"
        },
        "paint": {
          "line-color": "#38a1db",
          "line-width": 4
        }
      });

      // Ajuster la vue au trac√©
      const bounds = run.positions.reduce((bounds, p) => {
        return bounds.extend([p.longitude, p.latitude]);
      }, new mapboxgl.LngLatBounds([run.positions[0].longitude, run.positions[0].latitude], [run.positions[0].longitude, run.positions[0].latitude]));

      miniMap.fitBounds(bounds, { padding: 20, maxZoom: 16, duration: 1000 });
    });

    // Gestion clic bouton Partager (attention au scope)
    shareButton.addEventListener('click', () => {
      // Capture de la miniMap
      const canvas = miniMap.getCanvas();
      const imageDataUrl = canvas.toDataURL('image/png');

      // G√©n√©rer GPX
      const gpxContent = generateGPX(run);

      // Cr√©er blob et URL pour GPX
      const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
      const gpxUrl = URL.createObjectURL(blob);

      // Afficher popup partage
      showSharePopup({
        image: imageDataUrl,
        gpxLink: gpxUrl,
        runInfo: run
      });
    });
  });
}



// --- Fonctions √† d√©finir en dehors de ta boucle (par exemple dans ton script global) ---

// G√©n√©ration GPX √† partir d'un parcours
// G√©n√©ration GPX
function generateGPX(run) {
  const header = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="MonApp" xmlns="http://www.topografix.com/GPX/1/1">
<trk>
  <name>${run.name || 'Parcours'}</name>
  <trkseg>`;
  
  const footer = `
  </trkseg>
</trk>
</gpx>`;

  const points = run.positions.map(p => {
    const time = p.timestamp ? `<time>${new Date(p.timestamp).toISOString()}</time>` : '';
    return `<trkpt lat="${p.latitude}" lon="${p.longitude}">${time}</trkpt>`;
  }).join('\n');

  return header + points + footer;
}

// Popup partage
function showSharePopup({ image, gpxLink, runInfo }) {
  const modal = document.createElement('div');
  modal.style.position = 'fixed';
  modal.style.top = '0';
  modal.style.left = '0';
  modal.style.width = '100%';
  modal.style.height = '100%';
  modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';
  modal.style.alignItems = 'center';
  modal.style.justifyContent = 'center';
  modal.style.zIndex = '9999';
  modal.style.color = '#fff';
  modal.style.padding = '20px';
  modal.style.boxSizing = 'border-box';

  modal.innerHTML = `
    <h2>Partager ce parcours</h2>
    <img src="${image}" style="max-width: 90vw; max-height: 50vh; border-radius: 8px; margin-bottom: 10px;"/>
    <p>Distance : ${runInfo.distance.toFixed(2)} km</p>
    <p>Dur√©e : ${formatTime(runInfo.durationMs)}</p>
    <p>D√©nivel√© : ${Math.round(runInfo.elevation)} m</p>
    <a href="${gpxLink}" download="parcours.gpx" style="color: lightblue; margin: 10px;">T√©l√©charger le GPX</a>
    <button id="btnClose" style="margin-top: 15px; padding: 8px 15px; cursor: pointer;">Fermer</button>
  `;

  document.body.appendChild(modal);

  modal.querySelector('#btnClose').onclick = () => {
    URL.revokeObjectURL(gpxLink);
    document.body.removeChild(modal);
  };
}

    
    historyBtn.addEventListener('click', () => {
  showHistory();            // Affiche la liste des parcours
  historyModal.classList.add('active');  // Ouvre la modal
});

closeHistoryBtn.addEventListener('click', () => {
  historyModal.classList.remove('active'); // Ferme la modal
  runsList.innerHTML = '';                   // Vide la liste pour nettoyer
});




  // Supposons que tu stockes tes courses dans localStorage ou dans une variable
  const courses = JSON.parse(localStorage.getItem('courses')) || [];

  if (courses.length === 0) {
    runsList.innerHTML = '<p>Aucune course enregistr√©e.</p>';
    return;
  }

  courses.forEach(run => {
    const div = document.createElement('div');
    div.classList.add('run-item');
    div.innerHTML = `
      <div class="run-info">
        <div>Date : ${new Date(run.date).toLocaleString()}</div>
        <div>Distance : ${run.distance} km</div>
        <div>Dur√©e : ${run.duration}</div>
        <div>D√©nivel√© : ${run.elevation} m</div>
      </div>
    `;
    runsList.appendChild(div);
  });


  



let wakeLock = null;

// Fonction pour demander le Wake Lock
async function requestWakeLock() {
  if ('wakeLock' in navigator) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock activ√©');

      // Si le wake lock est lib√©r√© automatiquement (ex : perte de focus)
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock lib√©r√©');
      });
    } catch (err) {
      console.error(`Erreur Wake Lock : ${err.name}, ${err.message}`);
    }
  } else {
    console.warn('Wake Lock API non support√©e sur ce navigateur.');
  }
}

// Supprimer le message apr√®s 10 secondes
setTimeout(() => {
  const message = document.getElementById('wakeLockMessage');
  if (message) {
    message.remove();
  }
}, 10000); // 10 000 millisecondes = 10 secondes


// Redemander le wake lock si l‚Äôonglet est recharg√© ou redevient actif
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    requestWakeLock();
  }
});

// Appelle la fonction au chargement de la page
requestWakeLock();
</script>

</body>
</html>